# 四、浏览器缓存

浏览器缓存是浏览器将用户请求过的静态资源(html、css、js、img)，存储到用户电脑中，当浏览器再次访问时，就可以直接从本地加载了，不需要再去服务器请求了。

缓存的优点：

- 减少了冗余的数据传输，节省网费
- 减少服务器的负担，提升网站性能
- 加快了客户端加载网页的速度

缓存的缺点：

- 服务器更新资源后，由于缓存策略，导致用户浏览的页面还是旧的资源



![](./img/001-cache.png)
图片转载自：https://github.com/amandakelake/blog/issues/43

## 1. 前端缓存/后端缓存

基本的网络请求有三个步骤：请求、处理、响应。

后端的缓存主要集中在`处理`步骤，通过保留数据库连接，存储处理结果等方式，缩短处理时间，尽快进入响应的步骤。

而前端的缓存则在`请求`、`响应`中进行。

请求阶段：浏览器可以通过存储之前结果的方式直接使用资源，直接省去了发送的请求。

响应阶段：浏览器和服务器配合，通过减少响应内容来缩短传输时间。

## 2. 本地缓存存放位置

在Google的Chrome浏览器的开发者工具中， `Network -> Size`一列中,可以看到一个请求最终的处理方式：如果是大小 (多少 K， 多少 M 等) 就表示是网络请求，否则会列出 `from memory cache`, `from disk cache` 和 `from ServiceWorker`。

它们的优先级是：(由上到下寻找，找到即返回；找不到则继续)

1. Service Worker
2. Memory Cache
3. Disk Cache
4. 网络请求

### 2.1 memory cache

memory cache是内存中的缓存。按照操作系统的常理：先读内存，再度硬盘。

几乎所有的网络请求资源都会被浏览器自动加入到`memory cache`中。由于存储数量多和内存大小限制，`memory cache`只能是"短期存储"。一般情况下，浏览器TAB标签页关闭后，该次浏览的`memory cache`便会失效(给其他TAB留出内存空间)。在极端情况下(例如一个页面的缓存占用了超级多的内存)，那么TAB没关闭之前，排在前面的缓存就已经失效了。

刚才提过，**几乎所有的请求资源** 都能进入 memory cache，这里细分一下主要有两块：

1. preloader。关于preloader详情可以参阅[这篇文章](https://link.juejin.im?target=https%3A%2F%2Fcalendar.perfplanet.com%2F2013%2Fbig-bad-preloader%2F)。

   熟悉浏览器处理流程的同学们应该了解，在浏览器打开网页的过程中，会先请求 HTML 然后解析。之后如果浏览器发现了 js, css 等需要解析和执行的资源时，它会使用 CPU 资源对它们进行解析和执行。在古老的年代(大约 2007 年以前)，“请求 js/css - 解析执行 - 请求下一个 js/css - 解析执行下一个 js/css” 这样的“串行”操作模式在每次打开页面之前进行着。很明显在解析执行的时候，网络请求是空闲的，这就有了发挥的空间：我们能不能一边解析执行 js/css，一边去请求下一个(或下一批)资源呢？

   这就是 preloader 要做的事情。不过 preloader 没有一个官方标准，所以每个浏览器的处理都略有区别。例如有些浏览器还会下载 css 中的 `@import` 内容或者 `<video>` 的 `poster`等。

   而这些被 preloader 请求够来的资源就会被放入 memory cache 中，供之后的解析执行操作使用。

2. preload (虽然看上去和刚才的 preloader 就差了俩字母)。实际上这个大家应该更加熟悉一些，例如 `<link rel="preload">`。这些显式指定的预加载资源，也会被放入 memory cache 中。

memory cache 机制保证了一个页面中如果有两个相同的请求 (例如两个 `src` 相同的 `<img>`，两个 `href` 相同的 `<link>`)都实际只会被请求最多一次，避免浪费。

不过在匹配缓存时，除了匹配完全相同的 URL 之外，还会比对他们的类型，CORS 中的域名规则等。因此一个作为脚本 (script) 类型被缓存的资源是不能用在图片 (image) 类型的请求中的，即便他们 `src` 相等。

在从 memory cache 获取缓存内容时，浏览器会忽视例如 `max-age=0`, `no-cache` 等头部配置。例如页面上存在几个相同 `src` 的图片，即便它们可能被设置为不缓存，但依然会从 memory cache 中读取。这是因为 memory cache 只是短期使用，大部分情况生命周期只有一次浏览而已。而 `max-age=0` 在语义上普遍被解读为“不要在下次浏览时使用”，所以和 memory cache 并不冲突。

但如果站长是真心不想让一个资源进入缓存，就连短期也不行，那就需要使用 `no-store`。存在这个头部配置的话，即便是 memory cache 也不会存储，自然也不会从中读取了。(后面的第二个示例有关于这点的体现)

### 2.2 disk cache

`disk cache`也叫`HTTP cache`，是存储在硬盘上的缓存，因此它是持久存储的，是实际存在于文件系统中的。而且它允许相同的资源在跨会话，甚至跨站点的情况下使用，例如两个站点都使用了同一张图片。

disk cache 会严格根据HTTP头信息中的各类字段来判定那些资源可以缓存，哪些资源不可以缓存。哪些资源仍然是可用的，哪些资源是过期需要重新请求的。当命中缓存后，浏览器会从硬盘中读取资源，虽然比起从内存中读取慢了一些，但是比起网络请求还是快了不少。绝大部分的缓存都来自disk cache。

凡是持久性的存储都会面临容量增长的问题，disk cache也不例外。在浏览器自动清理时，会有神秘的算法去把`最老的`或者`最可能过时`的资源删除，是一个一个删除的。每个浏览器识别`最老的`或者`最可能过时`的资源的算法不尽相同。

### 2.3 Service Worker

memory cache 和 disk cache 的缓存策略以及缓存/读取/失效的操作都是由浏览器内部判断&进行的，我们只能设置响应头的某些字段来告诉浏览器，不能自己操作。

Service Worker的出现，给予了我们另外一种更加灵活，更加直接的操作方式。可以通过Service Worker来自己实现、控制缓存策略以及缓存/读取/失效的操作。

Service Worker能够操作的缓存是有别于浏览器内部的 `memory cache`或者`disk cache`方式。 
我们可以在Chrome的开发者工具中， Application - Application - Service Workers 找到。
Service Worker缓存是永久性的，即关闭TAB或者浏览器，下次打开依然还在(memory cache 不是)。

有两种情况会导致这个缓存中的资源被清除：

- 手动调用API`cache.delete(resource)`
- 容量超过限制，被浏览器全部清空

如果Service Worker 没能命中缓存，一般情况会使用`fetch()`方法继续获取资源。这时候，浏览器就去`memory cache`或者`disk cache`进行下一次找缓存的工作了。注意：经过 Service Worker 的 `fetch()` 方法获取的资源，即便它并没有命中 Service Worker 缓存，甚至实际走了网络请求，也会标注为 `from ServiceWorker`。这个情况在后面的第三个示例中有所体现。

### ### 2.4 请求网络

如果一个请求在上述 3 个位置都没有找到缓存，那么浏览器会正式发送网络请求去获取内容。之后容易想到，为了提升之后请求的缓存命中率，自然要把这个资源添加到缓存中去。具体来说：

1. 根据 Service Worker 中的 handler 决定是否存入 Cache Storage (额外的缓存位置)。
2. 根据 HTTP 头部的相关字段(`Cache-control`, `Pragma` 等)决定是否存入 disk cache
3. memory cache 保存一份资源 **的引用**，以备下次使用。







## 参考资料



[一文读懂前端缓存 掘金](https://juejin.im/post/5c22ee806fb9a049fb43b2c5)

[前端缓存最佳实践 掘金](https://juejin.im/post/5c136bd16fb9a049d37efc47)

https://segmentfault.com/a/1190000018717463

