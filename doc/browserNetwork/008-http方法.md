[[TOC]]

[TOC]

# HTTP 请求方法

HTTP定义了一组`请求方法`，以表明要给定资源执行的操作。指示针对给定资源要执行的期望动作。每个请求方法都实现了不同的语义，但一些共同的特征由一组共享，例如一个请求方法可以是[安全](https://developer.mozilla.org/zh-CN/docs/Glossary/safe)、[幂等](https://developer.mozilla.org/zh-CN/docs/Glossary/幂等)、[可缓存](https://developer.mozilla.org/en-US/docs/Glossary/cacheable)。

- 安全

  安全是指一个HTTP方法不会修改服务器的数据。也就是说，这是一个对服务器只读操作的方法。`GET`、`HEAD`、`OPTIONS`是安全的，`POST`、`PUT`、`DELETE`则不是安全的。

- 幂等

  幂等是指一个HTTP方法同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。也就是说，幂等方法不应该具有副作用(统计用途除外)。`GET`、`HEAD`、`PUT`、`DELETE`等方法都是幂等的，而`POST`方法不是。所有安全方法也都是幂等的。

- 可缓存

  可缓存响应是指，HTTP响应可以被缓存，响应被存储以供后面检索和使用，从而不需要从服务器从新获取。并不是所有HTTP响应都能被缓存，缓存HTTP响应有一下约束：

  - 请求方法本身是可缓存的，如`GET`或`HEAD`方法。如果设置了缓存字段并设置了`Content-Location`头，则也可以缓存`POST`或`PATCH`响应，但很少实现，(例如，Firefox不支持它，)
  - 响应的状态代码由应用程序缓存知道，并且它被视为可缓存的。以下状态代码是可缓存的：200、203、204、206、300、301、404、405、410、414 和 501。
  - 响应头中没有指定缓存的头部，如`Cache-Control`，它可以阻止缓存。
  
  ***注意:***对特定的URI的某些不可缓存的请求/响应可能会使以前缓存的响应失效。例如PUT到`pageX.html`页面，将使相同URI下所有的GET或HEAD请求缓存失效。

请求方法出现的时间：

- HTTP/0.9: GET
- HTTP/1.0: POST、HEAD
- HTTP/1.1: OPTIONS、PUT、DELETE、TRACE、CONNECT

## 1. 请求方法说明

| 方法                                                         | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| GET                                                          | 请求一个指定资源的表示形式. 使用GET的请求应该只被用于获取数据. |
| HEAD                                                         | 请求一个与GET请求的响应相同的响应，但没有响应体.HEAD方法作用：1、在不获取资源的情况下获取资源信息(类型、大小等)。2、通过状态码查看资源是否存在。3、通过查看首部，测试资源是否被修改了。 |
| POST                                                         | 向指定资源提交数据，请求服务器对数据进行相应处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。 |
| PUT                                                          | 向服务器写入资源，请求服务器创建一个新的目标资源，或者替换原先的目标资源。 |
| OPTIONS                                                      | 该请求返回服务器对指定资源支持哪些 HTTP 请求方法。           |
| DELETE                                                       | 用于删除指定的资源。和PUT一样，服务器可能会不支持。          |
| TRACE                                                        | 回显服务器收到的请求，主要用于测试或诊断。                   |
| CONNECT                                                      | HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。     |
| [PATCH](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/PATCH) | 用于对资源进行部分修改。由于PATCH不是标准的HTTP方法，所以不能保证客户端和服务端都已经实现。 |

**注意：**

根据RFC2616，HTTP 方法是区分大小写的，而Header是不区分的。

当指定资源不支持对应请求方法时，服务器返回状态码405(Method Not Allowed)。

当服务器不认识或者不支持对应请求方法时，服务器返回状态码501(Not Implemented)。

## 2. 关于请求方法的说明、区别

### 2.1 GET和POST区别

[GET 和 POST 到底有什么区别？知乎](https://www.zhihu.com/question/28586791)

[W3school](https://www.w3school.com.cn/tags/html_ref_httpmethods.asp)给的标准答案：

|                      | GET                                                          | POST                                                         |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 浏览器后退/刷新 按钮 | 无害                                                         | 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。     |
| 书签                 | 可以收藏为书签                                               | 不能收藏为书签                                               |
| 缓存                 | 可以被缓存                                                   | 不能被缓存                                                   |
| 编码类型             | application/x-www-form-urlencoded                            | application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 |
| 历史记录             | 参数保留在浏览器历史中。                                     | 参数不会保存在浏览器历史中。                                 |
| 数据长度限制         | 当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 | 无限制。                                                     |
| 对数据类型的限制     | 只允许 ASCII 字符。                                          | 没有限制。也允许二进制数据。                                 |
| 安全性               | 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！ | POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。 |
| 可见性               | 数据在 URL 中对所有人都是可见的。                            | 数据不会显示在 URL 中。                                      |

从标准上来看，GET 和 POST 的区别如下：

- GET 用于获取信息，是无副作用的，是幂等的，且可缓存
- POST 用于修改服务器上的数据，有副作用，非幂等，不可缓存

#### 2.1.1 POST 方法比 GET 方法安全？

以下几点POST确实比GET安全一点：

- GET方法容易被浏览器缓存
- 在浏览器的历史记录中会保留请求的地址
- 使用GET提交数据还可能会造成`Cross-site request forgery`攻击

上述内容只是浅显的解释，对于真正意义上的安全没有任何作用。然而，从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。

要想安全传输，就只有加密，也就是 HTTPS。

#### 2.1.2 GET、POST与请求数据如何传递没有关系

GET、POST是由HTTP协议定义的。HTTP协议中没有定义：GET请求的数据要放在URL中，POST请求的数据放在BODY中。是HTML标准对GET、POST进行了以上约定。现在web server大都是支持GET中包含body这样的请求。

我们可以在GET请求中通过body传递参数，但是需要后端服务进行相应的解析，在复杂的网络环境中需要考虑中转服务器、代理服务器对body数据的处理，避免参数丢失。

#### 2.1.3 POST产生两个TCP数据包?

有些文章中提到，post 会将 header 和 body 分开发送，先发送 header，服务端返回 100 状态码再发送 body。

HTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试(Chrome)发现，header 和 body 不会分开发送。

所以，header 和 body 分开发送是部分浏览器或框架的请求方法，不属于 post 必然行为。

### 2.2 PUT、POST区别

put和post的技术实现上应该是没有很大区别的。但在于协议上语义是很大区别。

PUT方法是幂等的：连续调用一次或者多次的效果相同（无副作用），而POST方法是非幂等的。

除此之外还有一个区别，通常情况下，PUT的URI指向是具体单一资源，而POST可以指向资源集合。

举个例子，我们在开发一个博客系统，当我们要创建一篇文章的时候往往用`POST https://www.jianshu.com/articles`，这个请求的语义是，在articles的资源集合下创建一篇新的文章，如果我们多次提交这个请求会创建多个文章，这是非幂等的。

而`PUT https://www.jianshu.com/articles/820357430`的语义是更新对应文章下的资源（比如修改作者名称等），这个URI指向的就是单一资源，而且是幂等的，比如你把『刘德华』修改成『蔡徐坤』，提交多少次都是修改成『蔡徐坤』

### 2.3 PUT、PATCH区别

PUT和PATCH都是更新资源，而PATCH用来对已知资源进行局部更新。

## 参考资料

[HTTP 请求方法 MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods)

[HTTP协议漫谈 - HTTP协议请求方法](https://blog.csdn.net/ccpat/article/details/79463473)

[99%的人理解错 HTTP 中 GET 与 POST 的区别](https://www.oschina.net/news/77354/http-get-post-different)